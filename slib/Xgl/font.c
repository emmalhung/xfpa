/*****************************************************************************/
/*
 *  File: font.c
 *
 *  Purpose: Functions to fetch fonts and output a string in various sizes
 *           and rotation angles. An attempt is made to identify the given
 *           font as either xft or xlfd (X core) by the structure of the
 *           name, but to be certain a font may be identified as an xft
 *           type by prepending "XFT:" to the font name as in:
 *
 *             XFT:Deja Vu Sans:Bold
 *
 *           The output string may contain a line feed '\n' character and
 *           the string will be broken into multi-line segments.
 *
 *  Functions: glIsFont         - Is the given font descriptor recognized
 *                                as a valid font.
 *             glSetDefaultFont - Set the default font.
 *             glLoadFont       - Load a font with a given name. The return
 *                                is a numerical index that identifies the font.
 *             glSetFont        - Set the active font by index value.
 *             glGetFontId      - Get the index value of the active font.
 *             glSetFontSize    - Set the font size in pixels
 *             glSetVdcFontSize - Set the font size in virtual device coordinates
 *             glSetMapFontSize - Set the font size in map units
 *             glTextAlignment  - Set the text alignment in relation to the cursor
 *                                position. Recognized values are
 *                                glTLEFT   = top left
 *                                glMLEFT   = middle left
 *                                glBLEFT   = bottom left
 *                                glTCENTRE = top center
 *                                glMCENTRE = middle center
 *                                glBCENTRE = bottom center
 *                                glTRIGHT  = top right
 *                                glMRIGHT  = middle right
 *                                glBRIGHT  = bottom right
 *                                So, for example, a value of glMCENTRE would center
 *                                the text on the cursor position.
 *             glTextAngle      - Set the text angle in degrees. Default is 0.
 *             glDrawString     - Draw a string at the specified map location
 *                                using the active font.
 *
 *     Version 8 (c) Copyright 2011 Environment Canada
 *
 *   This file is part of the Forecast Production Assistant (FPA).
 *   The FPA is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   any later version.
 *
 *   The FPA is distributed in the hope that it will be useful, but
 *   WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *   See the GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with the FPA.  If not, see <http://www.gnu.org/licenses/>.
 */
/*****************************************************************************/

#include <stdio.h>
#include <fpa_math.h>
#include "FpaXglP.h"

#define MIN_CHAR_SIZE 	3   /* in pixels */
/*
 * The height of a string is divided by this factor when multiple lines
 * of output text is generated by breaking on a '\n' character. As the
 * baseline of the xft fonts is not the same as the lowest extent of the
 * characters a ratio of 2 seems to produce good results.
 */
#define INTER_LINE_RATIO 2
                            

/* Structure used by the layout_text function to return informaton
 * as to the locations and origin of the text to be rendered.
 */
typedef struct {
	XftChar8 *text;	/* the text to render */
	int len;		/* length of the text */
	int xp;			/* x origin location */
	int yp;			/* y origin location */
	int width;		/* width of text in pixels */
	int height;		/* height of text in pixels */
} TSS;

/* Font information and cache structure. MAXSIZE is the maximum number of 
*  instances of sizes for a given font to cache and MAXANGLE is the maximum
*  number of angled fonts at the given size to cache. There must always be
*  an unrotated version of the font available for position calculations
*  for the rotated fonts. Unfortunate, but I was not able to figure out
*  how do the required calculations any other way.
*/
#define MAXSIZE 5	
#define MAXANGLE 5

typedef struct {
	String key;			/* key name for identifying font */
	Boolean core;		/* Is it an X11 core font */
	XftPattern *pattern;/* pattern for the font */
	int size;			/* size of active font */
	double  angle;		/* rotation angle of active font */
	XftFont *fp;		/* active font pointer */
	XftFont *ufp;		/* unrotated version of active font */
	struct {
		unsigned long refcount;	/* number of times font accessed */
		int size;				/* pixel size of cached fonts */
		XftFont *ufp;			/* unrotated font */
		struct {
			unsigned long refcount;	/* number of times rotated font accessed */
			double angle;			/* rotation angle of cached font */
			XftFont *fp;			/* pointer to rotated font */
		} angle[MAXANGLE];
	} cache[MAXSIZE];
} FLS;

/* local private variables */
static FLS    **font_list   = (FLS **)0;  /* list of fonts loaded */
static int    font_list_len = 0;          /* end of font list */
static String default_font = NULL;

/* Forward local function definitions */
static int       assign_font_by_name   (String, String);
static Boolean   find_font_by_name     (String, XftPattern**, Boolean*);
static double    font_angle            (void);
static FLS      *load_font             (void);
static int       layout_text           (FLS*, int, int, String, TSS**);
static void      xor_mode_draw         (FLS*, int, int, String);
static void      xor_mode_cleanup      (void);
static void      rotate_point          (int, int, double, int*, int*);
static String    symbol_replace        (FLS*, String);

#undef DEBUG_FONT

/**************************************************************************/
/*
 * Return true if the given name defines a valid font, else return false.
 */
/**************************************************************************/
Boolean glIsFont(String name)
{
	glInit();
	if(blank(name)) return False;
	if(same_ic(name, glDefaultFontName))
		name = NotNull(default_font)? default_font : BASE_DEFAULT_FONT;
	if(find_font_by_name(name, NULL, NULL)) return True;
	pr_error("glIsFont","\"%s\" is not a recognized scalable font.\n", name);
	return False;
}

/**************************************************************************/
/*
 * Set the font to be used as the default if a font is not found.
 */
/**************************************************************************/
void glSetDefaultFont( String font_name )
{
	glInit();
	XtFree(default_font);
	default_font = NULL;
	if(!blank(font_name)) 
	{
		default_font = XtNewString(font_name);
		no_white(default_font);
		/* 
		 * This check can only be done if connected to the X server.
		 */
		if(!find_font_by_name(default_font, NULL, NULL))
		{
			pr_error("glSetDefaultFont",
				"Default font named \'%s\' is not a recognized scalable font.\n", default_font);
			XtFree(default_font);
			if(find_font_by_name(BASE_DEFAULT_FONT, NULL, NULL))
			{
				default_font = XtNewString(BASE_DEFAULT_FONT);
				pr_error("glSetDefaultFont",
					"Internal hard coded font \'%s\' is being used instead.\n", default_font);
			}
			else
			{
				pr_error("glSetDefaultFont",
					"Internal hard coded font \'%s\' is not recognized either.\n", BASE_DEFAULT_FONT);
				pr_error("glSetDefaultFont",
					"Cannot continue. Terminating.\n");
				exit(1);
			}
		}
	}
	else
	{
		default_font = XtNewString(BASE_DEFAULT_FONT);
		if(find_font_by_name(default_font, NULL, NULL))
		{
			pr_warning("glSetDefaultFont","Default font is NULL. Using hard coded font \'%s\'\n",
				default_font);
		}
		else
		{
			pr_error("glSetDefaultFont",
				"Internal hard coded font \'%s\' is not recognized.\n", BASE_DEFAULT_FONT);
			pr_error("glSetDefaultFont", "Cannot continue. Terminating.\n");
			exit(1);
		}
	}
}


/**************************************************************************/
/*
 * Load a font of the given specification. name - Font family, weight
 * and slant in one string as in "helvetica-bold-r" or a freetype font
 * as in DejaVu sans:bold
 */
/**************************************************************************/
int glLoadFont(char *name)
{
	glInit();
	if (!default_font) default_font = XtNewString(BASE_DEFAULT_FONT);
	return assign_font_by_name("glLoadFont", name);
}


/**************************************************************************/
/*
 * Set the active font using the font index value returned above.
 */
/**************************************************************************/
void glSetFont(int ndx)
{
	glInit();
	if(ndx < 1 || ndx > font_list_len)
		pr_error("glSetFont","Invalid font index: %d\n", ndx);
	else
		WX->text.font_ndx = ndx;
}


int glGetFontId(void)
{
	return WX->text.font_ndx;
}


/**************************************************************************/
/* Set the size of the font in pixels.                                    */
/**************************************************************************/
void glSetFontSize(int s)
{
	static char* MyName = "glSetFontSize";

	if(s < MIN_CHAR_SIZE)
	{
		pr_error(MyName, "Attempt to set font size to less than %d pixel.\n",
				MIN_CHAR_SIZE);
		return;
	}
	WX->text.height_units = PIX_UNITS;
	WX->text.height.pix   = MAX(s, MIN_CHAR_SIZE);
	WX->text.size         = WX->text.height.pix;
}


/**************************************************************************/
/*
 * Set the size of the font in	vdc units. 
 */
/**************************************************************************/
void glSetVdcFontSize(float s)
{
	float size;
	static char* MyName = "glSetVdcFontSize";

	if(s <= 0.0 || s > 1.0)
	{
		pr_error(MyName, "Attempt to set font vdc size to %f.\n", s);
		return;
	}
	WX->text.height_units = VDC_UNITS;
	WX->text.height.vdc   = s;
	size = MAX((float)(W->ym - 1) * s + 0.5, MIN_CHAR_SIZE);
	WX->text.size = NINT(size);
}


/**************************************************************************/
/*
 * Set the size of the font in current map units.
 */
/**************************************************************************/
void glSetMapFontSize(float s)
{
	static char* MyName = "glSetMapFontSize";

	if(s <= 0.0)
	{
		pr_error(MyName, "Attempt to set font size to 0.\n", NULL);
		return;
	}
	WX->text.height_units = MAP_UNITS;
	WX->text.height.map   = s;
	WX->text.size = MAX(YR(s), MIN_CHAR_SIZE);
}


/**************************************************************************/
/*  
 *  Set the text alignment and rotation attributes.
 */
/**************************************************************************/
void glTextAlignment(int align)
{
	WX->text.alignment = align;
}


void glTextAngle(Angle angle)
{
	WX->text.angle = angle;
}


/**************************************************************************/
/*
 * Draw string at the given coordinates using the current font, size
 * text alignment and rotation angle.
 */
/**************************************************************************/
void glDrawString( Coord xc, Coord yc, char *text )	
{
	int n, x, y, nline;
	TSS *line;
	FLS *font;

	if(blank(text)) return;
	font = load_font();
	if(!font) return;

	/* Check for and replace any special font related symbols */
	text = symbol_replace(font, text);

	/* pixel position of current character cursor position */
	x = XS(xc,yc);
	y = YS(xc,yc);

	/* Special processing is needed if drawing in xor mode */
	if(WX->xop == GXxor)
	{
		xor_mode_draw(font, x, y, text);
	}
	else
	{
		xor_mode_cleanup();
		nline = layout_text(font, x, y, text, &line);
		for(n = 0; n < nline; n++)
			XftDrawStringUtf8(WX->xftdraw, WX->xftfg, font->fp,
				line[n].xp, line[n].yp, line[n].text, line[n].len);
	}
}



/*================== Local Static Functions =====================*/
		


/* Not local static but used internally in the library and needs access to the
 * structure and variables defined above. Note that trying to close fonts in
 * this function results in a SIGSEG fault and thus is not done. If anyone can
 * figure out why and fix it please do.
 */
void _xgl_free_fonts(void)
{
	int n,j;
	for(n = 0; n < font_list_len; n++)
	{
		FREEMEM(font_list[n]->key);
		XftPatternDestroy(font_list[n]->pattern);
		FREEMEM(font_list[n]);
	}
	FREEMEM(font_list);
	font_list_len = 0;
}


/* There are differences in the non-base characters between ISO8859 and
 * UTF8 character sets. This function replaces the symbols with the font
 * approproate ones. To extend the symbol list add to the sb and mb arrays.
 */
static String symbol_replace(FLS *font, String text)
{
	int n;
	String ptr, insym, outsym;
	String rtntxt = text;

	/* There must be two sets of symbols defined here, single byte symbols as
	 * used by xlfd (core X) fonts and multibyte fonts such as DejaVu.
	 */
	const char sb[1] = {'\260'};	/* ISO8859 single byte symbols */
	const String mb[1] = {"°"};		/* multibyte symbols */
	static String newtext = NULL;	/* returned text if any */

	if(font->core)
	{
		/* Quick check to see if there are any symbols to replace */
		for(ptr = NULL, n = 0; n < XtNumber(mb); n++)
			if((ptr = strstr(text,mb[n]))) break;
		if(ptr)
		{
			/* Replace any multibyte symbols with single byte symbols */
			String p, buf;
			XtFree(newtext);
			newtext = XtNewString(text);
			for(n = 0; n < XtNumber(mb); n++)
			{
				if(!(ptr = strstr(newtext,mb[n]))) continue;
				buf = XtCalloc(strlen(newtext)+1,sizeof(char));
				p = newtext;
				while(ptr)
				{
					strncat(buf, p, ptr - p);
					buf[strlen(buf)] = sb[n];
					p = ptr+strlen(mb[n]);
					ptr = strstr(p,mb[n]);
				}
				strcat(buf, p);
				XtFree(newtext);
				newtext = XtNewString(buf);
				XtFree(buf);
			}
			rtntxt = newtext;
		}
	}
	else
	{
		/* Quick check to see if there are any symbols to replace */
		for(ptr = NULL, n = 0; n < XtNumber(sb); n++)
			if((ptr = strchr(text,sb[n]))) break;
		if(ptr)
		{
			/* Replace any single byte symbols with multibyte symbols */
			String p, buf;
			XtFree(newtext);
			newtext = XtNewString(text);
			for(n = 0; n < XtNumber(sb); n++)
			{
				if(!(ptr = strchr(newtext,sb[n]))) continue;
				buf = XtCalloc(strlen(newtext)+100,sizeof(char));
				p = newtext;
				while(ptr)
				{
					strncat(buf, p, ptr - p);
					strcat(buf, mb[n]);
					p = ptr+1;
					ptr = strchr(p,sb[n]);
				}
				strcat(buf, p);
				XtFree(newtext);
				newtext = XtNewString(buf);
				XtFree(buf);
			}
			rtntxt = newtext;
		}
	}
	return rtntxt;
}


/* Rotate the point xp,yp around the point cx,cy by angle in radians.
 * The result is output in xp,yp.
 */
static void rotate_point(int cx, int cy, double angle, int *xp, int *yp)
{
	if(angle != 0)
	{
		double xs, ys, xn, yn;
		/*
		 * Since y increases going down the negative of the angle is needed.
		 */
		double cos_angle = cos(-angle);
		double sin_angle = sin(-angle);
		xs = (double) (*xp - cx);
		ys = (double) (*yp - cy);
		xn = xs * cos_angle - ys * sin_angle;
		yn = xs * sin_angle + ys * cos_angle;
		*xp = NINT(xn) + cx;
		*yp = NINT(yn) + cy;
	}
}


/* Return the required angle of the font in radians.
 * This is the sum of the text angle and the rotation
 * angle of the image.
 */
static double font_angle(void)
{
	double angle = (double)(WX->text.angle + W->ra);

	/* set angle to 0 <= angle < 360 degrees */
	while(angle < 0	 ) angle+=360;
	while(angle > 360) angle-=360;

	/* If close to 0 then set to 0 */
	if(fabs(angle) < 0.01) angle = 0.0;
	
	return (angle*M_PI/180.);
}


/* Loads a font of the given specification in the active pixel size and
 * rotation angle. The fonts are cached on a least used first overwritten
 * scheme. This should minimize the number of font loads and unloads required.
*/
static FLS *load_font(void)
{
	int        i, k, size, size_ndx;
	XftFont    *xft;
	XftPattern *pattern;
	unsigned long minrefcount;
	FLS        *font = font_list[WX->text.font_ndx-1];
	double     angle = font_angle();

	const String MyName = "load_font";

	/* Does our active font already meet the specification for size and angle?
	 */
	if(font->size == WX->text.size && font->angle == angle ) return font;

	/* Look for the font in the requested size and angle in the font cache.
	*/
	for(size_ndx = -1, i = 0; i < MAXSIZE; i++)
	{
		if(font->cache[i].size != WX->text.size) continue;
		if(!font->cache[i].ufp) continue;
		size_ndx = i;
		font->ufp = font->cache[i].ufp;
		font->size = font->cache[i].size;
		if(angle == 0)
		{
			font->cache[i].refcount++;
			font->fp = font->cache[i].ufp;
			font->angle = 0;
			return font;
		}
		else
		{
			for(k = 0; k < MAXANGLE; k++)
			{
				if(font->cache[i].angle[k].angle != angle) continue;
				if(!font->cache[i].angle[k].fp) continue;
				font->cache[i].angle[k].refcount++;
				font->fp = font->cache[i].angle[k].fp;
				font->angle = font->cache[i].angle[k].angle;
				return font;
			}
		}
	}
	/*
	 * If we get to here we don't have it so add it. If size_ndx < 0
	 * then no font in the required size was found so first add the
	 * base unrotated font.
	 */
	if(size_ndx < 0)
	{
		pattern = XftPatternDuplicate(font->pattern);
		XftPatternDel(pattern, XFT_PIXEL_SIZE);
		XftPatternAddDouble(pattern, XFT_PIXEL_SIZE, (double) WX->text.size);
		xft = XftFontOpenPattern(D, pattern);
		if(!xft)
		{
			XftPatternDestroy(pattern);
			pr_error(MyName, "Cannot open \'%s\' font for size %d pixels.\n",
						font->key, WX->text.size);
			return NULL;
		}
		/*
		 * Find least used font size
		 */
		minrefcount = ULONG_MAX;
		for(size_ndx = 0, i = 0; i < MAXSIZE; i++)
		{
			if(font->cache[i].refcount < minrefcount)
			{
				size_ndx = i;
				minrefcount = font->cache[i].refcount;
			}
		}
		/*
		 * Close unrotated font and all rotated versions
		 */
		if(font->cache[size_ndx].refcount > 0)
		{
			XftFontClose(D, font->cache[size_ndx].ufp);
			font->cache[size_ndx].ufp = NULL;
			font->cache[size_ndx].refcount = 0;
			for(i = 0; i < MAXANGLE; i++)
			{
				if(font->cache[size_ndx].angle[i].refcount > 0)
					XftFontClose(D, font->cache[size_ndx].angle[i].fp);
				font->cache[size_ndx].angle[i].fp = NULL;
				font->cache[size_ndx].angle[i].refcount = 0;
			}
		}
		/*
		 * Add in new font size
		 */
		font->cache[size_ndx].size = WX->text.size;
		font->cache[size_ndx].ufp = xft;
		font->cache[size_ndx].refcount = 1;
		font->ufp = xft;
		font->fp = xft;
		font->size = WX->text.size;
		font->angle = 0;
	}
	/*
	 * If an angle was specified then add it next.
	 */
	if(angle != 0)
	{
		int ndx = 0;
		XftMatrix  matrix;

		pattern = XftPatternDuplicate(font->pattern);
		XftPatternDel(pattern, XFT_PIXEL_SIZE);
		XftPatternAddDouble(pattern, XFT_PIXEL_SIZE, (double) WX->text.size);
		XftMatrixInit(&matrix);
		XftMatrixRotate(&matrix, cos(angle), sin(angle));
		XftPatternDel(pattern, XFT_MATRIX);
		XftPatternAddMatrix(pattern, XFT_MATRIX, &matrix);

		if(!(xft = XftFontOpenPattern(D, pattern)))
		{
			XftPatternDestroy(pattern);
			pr_error(MyName, "Cannot open rotated font \'%s\' for size = %d and angle = %.1f.\n",
						font->key, WX->text.size, angle);
			return NULL;
		}
		/*
		 * Look for least used font
		 */
		minrefcount = ULONG_MAX;
		for(ndx = 0, i = 0; i < MAXANGLE; i++)
		{
			if(font->cache[size_ndx].angle[i].refcount < minrefcount)
			{
				ndx = i;
				minrefcount = font->cache[size_ndx].angle[i].refcount;
			}
		}
		/*
		 * Close font
		 */
		if(font->cache[size_ndx].angle[ndx].refcount > 0)
			XftFontClose(D, font->cache[size_ndx].angle[ndx].fp);
		/*
		 * Add to angle cache
		 */
		font->cache[size_ndx].angle[ndx].fp = xft;
		font->cache[size_ndx].angle[ndx].refcount = 1;
		font->fp = xft;
		font->angle = angle;
	}
	return font;
}


/* A font is scalable if in the fully described name the point size,
 * x, y and average width (fields 8,9,10 and 12) are 0 or x,y are '*'
 * and the rest 0.
 */
static Boolean scalable_xlfd(char *name)
{
	int field = 0;
	String p;
	for(p = name; *p; p++)
	{
		if(*p != '-') continue;
		switch (++field)
		{
			case 8: case 12: if(atoi(++p)) return False; break;
			case 9: case 10: if(*(++p) != '*' && atoi(p)) return False; break;
		}
	}
	return (field > 12);
}


/* Given a font descriptor try and find a match. Since we are not interested
 * in the size information when looking for a font at this time we only need
 * to look for a font that matches. XFT fonts must be preceeded by "XFT:".
 */
static Boolean find_font_by_name(String name, XftPattern **found_pattern, Boolean *core_font)
{
	int n;
	String p = NULL;
	Boolean rtn = False;
	XftPattern *pattern = NULL;

	/* Font search patterns */
	const String search_fmt[] = {
		"%s", /* Fully qualified input name */
		"*%s*-0-0-0-0-*-0-*iso8859-1",
		"*%s*-0-0-*-*-*-0-*iso8859-1",
		"*%s*-0-0-0-0-*-0-*iso8859*",
		"*%s*-0-0-*-*-*-0-*iso8859*",
		"*%s*-0-0-0-0-*-0-*",
		"*%s*-0-0-*-*-*-0-*"
	};

	if (blank(name) || !W || !WX) return False;

	if(same_start_ic(name,"XFT:"))
	{
		if (core_font) *core_font = False;
		name = same_start_ic(name,"XFT:")? name+4:name;
		pattern = XftNameParse(name);
	}
	else
	{
		int ndash;

		if (core_font) *core_font = True;

		for(ndash = 0, p = name; *p != '\0'; p++)
			if(*p == '-') ndash++;
		/*
		 * If ndash is > 10 the name is probably fully qualified.
		 */
		for(n = (ndash>10)?0:1; n < XtNumber(search_fmt); n++)
		{
			int  i, nfonts, ndx;
			char **fonts, fontname[256];
			(void) snprintf(fontname, sizeof(fontname), search_fmt[n], name);
			fonts = XListFonts(D, fontname, 100, &nfonts);
			if(nfonts == 0 || fonts == NULL) continue;
			for(ndx = -1, i = 0; i < nfonts; i++)
			{
				if(!scalable_xlfd(fonts[i])) continue;		/* Only accept scalable fonts */
				ndx = i;
				if(!strstr(fonts[i],"normal")) continue;	/* Prefer normal fonts */
				ndx = i;
				break;
			}
			if(ndx >= 0)
			{
				/* Note that XftXlfdParse expects a pixel size to be specified or else
				 * it returns a NULL pattern. This is why a dummy size is substituted.
				 * A real value is substituted in the pattern later in load_font.
				 */
				for(n = 0, p = fonts[ndx]; *p && n < 8; p++)
				{
					if(*p != '-' || ++n != 7) continue;
					if(!atoi(++p)) *p = '9';
					break;
				}
				pattern = XftXlfdParse(fonts[ndx], False, False);
#				ifdef DEBUG_FONT
				(void) printf("[find_font_by_name] Font: %s\n", fonts[ndx]);
#				endif /* DEBUG_FONT */
			}
			XFreeFontNames(fonts);
			if (pattern) break;
		}
	}
	if(pattern)
	{
		XftResult result;
		XftPattern *match_pattern = XftFontMatch(D, WX->screen, pattern, &result);
		if(match_pattern)
		{
			if(found_pattern)
				*found_pattern = match_pattern;
			else
				XftPatternDestroy(match_pattern);
			rtn = True;
		}
		XftPatternDestroy(pattern);
	}
	return rtn;
}



/*  Add in a font of the given specification. We first check to see if the
 *  requested font is in our database. This function does not actually
 *  load the font but reserves space for it and maintains the font name for
 *  use when the font is actually needed. We try and find an actual font that
 *  matches the font partial name as entered in the function.
 *
 *  fcnName - The function name to use for error reporting.
 *  name    - Partial or full font information as in "helvetica-bold-r" and such.
 *
 *  return : The index value into the font database.
 */
static int assign_font_by_name(char *fcnName, char *name)
{
	int  n, end;
	Boolean core_font;
	XftPattern *pattern;
	String key = XtNewString(name);

	/* Do we have the requested font in our database? */
	no_white(key);
	if(blank(key))
	{
		XtFree(key);
		return 0;
	}

	/* The font can come in with surrounding quotes if the input source was
	 * improperly quoted so check for this.
	 */
	end = (int) strlen(key) - 1;
	if((key[0] == '"' && key[end] == '"') || (key[0] == '\'' && key[end] == '\''))
	{
		key[0] = ' ';
		key[end] = ' ';
		no_white(key);
	}

	for(n = 0; n < font_list_len; n++)
	{
		if(same(key, font_list[n]->key))
		{
			XtFree(key);
			return n+1;
		}
	}

	name = key;
	if(same_ic(name,glDefaultFontName))
		name = default_font;

	if(!find_font_by_name(name, &pattern, &core_font))
	{
		pr_error(fcnName, "Unable to find font \'%s\' so substituting default font \'%s\'.\n",
			name, default_font);
		name = default_font;
		if(!find_font_by_name(name, &pattern, &core_font))
		{
			pr_error(fcnName, "Unable to find \'%s\' font so substituting \'%s\'.\n", name,BASE_DEFAULT_FONT);
			name = BASE_DEFAULT_FONT;
			if(!find_font_by_name(name, &pattern, &core_font))
			{
				/* Yikes we really have problems */
				pr_error(fcnName,"Unable to find even a \'%s\' font!\n", name);
				XtFree(key);
				return 0;
			}
		}
	}

	/* Extend the font information array */
	font_list = GETMEM(font_list, FLS*, font_list_len + 1);
	font_list[font_list_len] = ONEMEM(FLS);
	font_list[font_list_len]->key = key;
	font_list[font_list_len]->core = core_font;
	font_list[font_list_len]->pattern = pattern;
	font_list_len++;

#	ifdef DEBUG_FONT
	char buf[5001];
	for(n=0; n<font_list_len; n++)
		{
		XftNameUnparse(font_list[n]->pattern, buf, 5000);
		(void) printf("[assign_font_by_name] Font %d: %s\n", n, font_list[n]->key);
		if ( n== font_list_len-1 )
			(void) printf("[assign_font_by_name]   Pattern: %s\n", buf);
		}
#	endif /* DEBUG_FONT */

	return (font_list_len);
}


/* Break a string into segments based on breaking the line at '\n'
 * so that multiple lines can be output. The location of the text
 * origin in y must be determined for each segment based on the
 * total number of segments.
 *
 * font - pointer to currently active font structure element
 * x,y  - Current cursor location
 * text - The text to output
 * rtn  - Information as to the location of the text segments
 *        in TSS structure format.
 *
 * return: The number of text segments found.
 */
static int layout_text(FLS *font, int x, int y, String text, TSS **rtn)
{
	int i;
	int total_height = 0;
	String s, p;
	XGlyphInfo info;
	double angle = font_angle();

	static String text_str = NULL;
	static TSS *lines = NULL;
	static int nlines = 0;
	static int maxlines = 0;

	XtFree(text_str);
	text_str = XtNewString(text);

	/* Find size of structure needed */
	nlines = 1;
	s = text_str;
	while((p = strchr(s,'\n')))
	{
		nlines++;
		s = ++p;
	}
	if(nlines > maxlines)
		lines = GETMEM(lines, TSS, (maxlines = nlines));

	/* loop through text and find the number of lines. Note that the size of the
	 * character string is derrived from the unrotated font. The yp element is
	 * used to store the relative location of the text.
	 */
	nlines = 0;
	s = text_str;
	while((p = strchr(s,'\n')))
	{
		*p = '\0';
		info.xOff = 0;
		XftTextExtentsUtf8(D, font->ufp, (FcChar8*)s, (int) safe_strlen(s), &info);
		lines[nlines].width = info.xOff;
		lines[nlines].height = info.height;
		lines[nlines].yp = info.height + total_height;
		lines[nlines].text = (XftChar8*) s;
		lines[nlines].len = (int) safe_strlen(s);
		total_height += info.height + info.height/INTER_LINE_RATIO;
		s = p+1;
		nlines++;
	}
	/*
	 * Final text
	 */
	info.xOff = 0;
	XftTextExtentsUtf8(D, font->ufp, (FcChar8*)s, (int) safe_strlen(s), &info);
	lines[nlines].width = info.xOff;
	lines[nlines].height = info.height;
	lines[nlines].yp = info.height + total_height;
	lines[nlines].text = (XftChar8*) s;
	lines[nlines].len = (int) safe_strlen(s);
	total_height += info.height;
	nlines++;
	/*
	 * Loop through the segments and determine where the origin of the
	 * string xp,yp is relative to the cursor point x,y, rotate the origin
	 * and then draw the result.
	 */
	for(i = 0; i < nlines; i++)
	{
		int xp, yp;
		switch(WX->text.alignment)
		{
			case glTLEFT: xp = x; yp = y + lines[i].yp; break;
			case glTCENTRE: xp = x - lines[i].width/2; yp = y + lines[i].yp; break;
			case glTRIGHT: xp = x - lines[i].width; yp = y + lines[i].yp; break;
			case glMLEFT: xp = x; yp = y - (total_height/2 - lines[i].yp); break;
			case glMCENTRE: xp = x - lines[i].width/2; yp = y - (total_height/2 - lines[i].yp); break;
			case glMRIGHT: xp = x - lines[i].width; yp = y - (total_height/2 - lines[i].yp); break;
			case glBLEFT: xp = x; yp = y - total_height + lines[i].yp; break;
			case glBCENTRE: xp = x - lines[i].width/2; yp = y - total_height + lines[i].yp; break;
			case glBRIGHT: xp = x - lines[i].width; yp = y - total_height + lines[i].yp; break;
			default: xp = x; yp = y;
		}
		rotate_point(x, y, angle, &xp, &yp);
		lines[i].xp = xp;
		lines[i].yp = yp;
	}

	*rtn = lines;
	return nlines;
}


/* Calculate the size of the bounding box around the text string.
 * 
 * Returned Parameters:
 *	ox,oy - the location of the text origin within the box,
 *	cx,cy - the location of the upper left corner of the box
 *			relative to the text origin point
 *  width - of the box
 *  height - of the box
 */
static void text_bounding_box(FLS *font, String text, int *ox, int *oy, int *cx, int *cy, int *width, int *height)
{
	int i, xp, yp, x[4], y[4];
	int total_height = 0;
	int total_width = 0;
	int xmin = INT_MAX, xmax = INT_MIN, ymin = INT_MAX, ymax = INT_MIN;
	String s, p;
	XGlyphInfo info;
	double angle = font_angle();

	static String text_str = NULL;

	XtFree(text_str);
	text_str = XtNewString(text);

	/* loop through text and find the number of lines. Note that the size of the
	 * character string is derrived from the unrotated font. The yp element is
	 * used to store the relative location of the text.
	 */
	s = text_str;
	while((p = strchr(s,'\n')))
	{
		*p = '\0';
		info.xOff = 0;
		XftTextExtentsUtf8(D, font->ufp, (FcChar8*)s, (int) safe_strlen(s), &info);
		total_height += info.height + info.height/INTER_LINE_RATIO;
		total_width = MAX(total_width, info.xOff);
		s = p+1;
	}
	info.xOff = 0;
	XftTextExtentsUtf8(D, font->ufp, (FcChar8*)s, (int) safe_strlen(s), &info);
	total_height += info.height;
	total_width = MAX(total_width, info.xOff);

	x[0] = 0;
	y[0] = 0;
	x[1] = total_width;
	y[1] = 0;
	x[2] = total_width;
	y[2] = total_height + font->ufp->descent;
	x[3] = 0;
	y[3] = total_height + font->ufp->descent;

	switch(WX->text.alignment)
	{
		case glTLEFT: xp = 0; yp = 0; break;
		case glTCENTRE: xp = total_width/2; yp = 0; break;
		case glTRIGHT: xp = total_width; yp = 0; break;
		case glMLEFT: xp = 0; yp = total_height/2; break;
		case glMCENTRE: xp = total_width/2; yp = total_height/2; break;
		case glMRIGHT: xp = total_width; yp = total_height/2; break;
		case glBLEFT: xp = 0; yp = total_height; break;
		case glBCENTRE: xp = total_width/2; yp = total_height; break;
		case glBRIGHT: xp = total_width; yp = total_height; break;
		default: xp = 0; yp = 0;
	}
	for(i = 0; i < 4; i++)
	{
		rotate_point(xp, yp, angle, &x[i], &y[i]);
		if(xmin > x[i]) xmin = x[i];
		if(xmax < x[i]) xmax = x[i];
		if(ymin > y[i]) ymin = y[i];
		if(ymax < y[i]) ymax = y[i];
	}
	/*
	 * Make the box just a little bigger to account for
	 * multiple font drawing (see xor_mode_draw).
	 */
	*ox = xp - xmin + 2;
	*oy = yp - ymin + 2;
	*cx = xmin - xp - 2;
	*cy = ymin - yp - 2;
	*width = xmax - xmin + 4;
	*height = ymax - ymin + 4;
}
	

/* In order to draw the text to the screen using the xor mode the text
 * must be drawn into a pixmap and the pixmap displayed using the xor
 * mode as I was unable to find any way to do this with freetype rendering.
 * While anti-aliasing looks really good on the screen it produces a not
 * so great result when used in this way. Thus a one bit deep pixmap is
 * used to avoid the anti-aliasing and it results in a cleaner screen image.
 */
typedef struct {
	FLS   *font;
	int    size;
	double angle;
	String text;
	GC     gc;
	Pixmap pixmap;
	int    cx, cy;
	unsigned int width;
	unsigned int height;
} PCS;

static PCS *pcs = NULL;
static int npcs = 0;

/* Draw the text using a pixmap. As long as xor mode is in effect this
 * code will create multiple pixmaps if there are multiple text strings.
 *
 * Input: font - pointer to active font structure
 *        x,y  - screen pixel position of text location
 *        text - the text to draw to the screen
 */
static void xor_mode_draw (FLS *font, int x, int y, String text)
{
	int i, n, cx, cy, ox, oy, width, height, nlines;
	XGCValues values;
	unsigned long mask;
	TSS *lines;
	XftDraw *draw;
	XftColor color;
	double angle = font_angle();

	/* Look for existing cache entry */
	for(n = 0; n < npcs; n++)
	{
		if(pcs[n].font != font) continue;
		if(pcs[n].size != WX->text.size) continue;
		if(pcs[n].angle != angle) continue;
		if(!same(pcs[n].text,text)) continue;
		XCopyPlane(D, pcs[n].pixmap, WX->draw, pcs[n].gc, 0, 0, pcs[n].width, pcs[n].height,
				x + pcs[n].cx, y + pcs[n].cy, 1);
		return;
	}

	/* If we get to here there was not a match so create a new pixmap entry. */
	n = npcs++;
	pcs = GETMEM(pcs, PCS, npcs);

	/* Get the pixmap sizing and location information */
	text_bounding_box(font, text, &ox, &oy, &cx, &cy, &width, &height);

	/* For the CreateGC */
	mask = GCFunction | GCForeground | GCBackground;
	values.function   = GXxor;
	values.foreground = 0;
	values.background = WX->xftfg->pixel;

	pcs[n].cx     = cx;
	pcs[n].cy     = cy;
	pcs[n].width  = (unsigned int) width;
	pcs[n].height = (unsigned int) height;
	pcs[n].text   = XtNewString(text);
	pcs[n].font   = font;
	pcs[n].size   = WX->text.size;
	pcs[n].angle  = angle;
	pcs[n].gc     = XCreateGC(D, WX->draw, mask, &values);
	pcs[n].pixmap = XCreatePixmap(D, WX->draw, pcs[n].width, pcs[n].height, 1);

	/* Clear the bitmap background (in xor mode black is clear :-) */
	draw = XftDrawCreateBitmap(D, pcs[n].pixmap);
	_xgl_set_xft_color(values.foreground, &color);
	XftDrawRect(draw, &color, 0, 0, pcs[n].width, pcs[n].height);

	/* With a bitmap xft thinks it is drawing into the alpha channel. I found
	 * that the font drawn this way looks too 'thin' and that it looks better
	 * if the text origin is offset one pixel and the text drawn again.
	 */
	color.color.alpha = 0;
	nlines = layout_text(font, ox, oy, text, &lines);
	for(i = 0; i < nlines; i++)
	{
		cx = lines[i].xp;
		cy = lines[i].yp;
		XftDrawStringUtf8(draw, &color, font->fp, cx++, cy, lines[i].text, lines[i].len);
		rotate_point(lines[i].xp, lines[i].yp, angle, &cx, &cy);
		XftDrawStringUtf8(draw, &color, font->fp, cx, cy, lines[i].text, lines[i].len);
	}
	XftDrawDestroy(draw);

	/* Copy bitmap to the target map */
	XCopyPlane(D, pcs[n].pixmap, WX->draw, pcs[n].gc, 0, 0, pcs[n].width, pcs[n].height,
				x + pcs[n].cx, y + pcs[n].cy, 1);
}


static void xor_mode_cleanup(void)
{
	int n;
	if(!pcs) return;
	for(n = 0; n < npcs; n++)
	{
		FREEMEM(pcs[n].text);
		XFreeGC(D, pcs[n].gc);
		XFreePixmap(D, pcs[n].pixmap);
	}
	FREEMEM(pcs);
	npcs = 0;
}
