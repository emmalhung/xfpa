#include "rankweight.h"
#include <stddef.h>
#include <sys/select.h>
#include <errno.h>
#include "inotify_utils.h"
#include "calc_weights.h"
#include "fcst_weights.h"
#include "monitor.h"

extern int     stat_dir_wd;
extern LOGICAL keep_running;
extern STRING  stat_dir;
extern int     errno;
extern int     nwfiles;
extern STRING  *wfiles;

static int     nfiles = 0;
static STRING  *files = NULL;
static LOGICAL *files_new = NULL;
static int     timeoutval = 0;


/* Add the file from the event to the list of files to be processed
 * but only if it is one that has not just been written by the daemon
 * itself. A file is only added once to the list.
 */
static void add_file_to_list( queue_entry_t event, LOGICAL new )
{
	int n;

	/* The event filename must have a length */
	if(event->inot_ev.len <= 0) return;

	for(n = 0; n < nwfiles; n++)
	{
		if(same(event->inot_ev.name, wfiles[n])) return;
	}
	for(n = 0; n < nfiles; n++)
	{
		if(same(event->inot_ev.name, files[n])) return;
	}
	files = GETMEM(files, STRING, nfiles+1);
	files[nfiles] = strdup(event->inot_ev.name);
	files_new = GETMEM(files_new, LOGICAL, nfiles+1);
	files_new[nfiles] = new;
	nfiles++;
}


/* Create an inotify instance and open a file descriptor to access it */
int open_inotify_fd ()
{
	int fd = inotify_init ();
	if (fd < 0) printlog("ERROR: inotify_init() failure = %d", errno);
	return fd;
}


/* Close the open file descriptor that was opened with inotify_init() */
int close_inotify_fd (int fd)
{
	int r = close (fd);
	if(r < 0) printlog("ERROR: close_inotify_fd(fd) failure = %d", errno);
	return r;
}


/* After the events have been read and queued they can be processed. Note
 * that the IN_CLOSE_WRITE event is only generated by the file monitored
 * for output from the external forecasting program and thus is not added
 * to any list. The return from this function will be 1 if this event is
 * found and 0 otherwise.
 */
int handle_events (queue_t q)
{
	queue_entry_t event;
	int in_close_write_found = 0;
	while (!queue_empty (q))
	{
		event = queue_dequeue (q);
		switch(event->inot_ev.mask & IN_ALL_EVENTS)
		{
			case IN_CLOSE_WRITE:
				in_close_write_found = 1;
				break;
			case IN_MODIFY:
				timeoutval = 1;
				add_file_to_list(event, FALSE);
				break;
			case IN_MOVED_FROM:
			case IN_CREATE:
				timeoutval = 1;
				if(event->inot_ev.wd == stat_dir_wd)
					add_file_to_list(event, TRUE);
				else
					add_to_monitor_list(event);
				break;
			case IN_DELETE_SELF:
				printlog("ERROR: Monitored directory \'%s\' deleted.", event->inot_ev.name);
				break;
		}
		free (event);
	}
	return in_close_write_found;
}


/* It is possible for multiple events to happen, thus we must parse the
 * return and queue up the result.
 */
int read_events (queue_t q, int fd)
{
	char buffer[16384];
	size_t buffer_i;
	struct inotify_event *pevent;
	queue_entry_t event;
	ssize_t r;
	size_t event_size, q_event_size;
	int count = 0;

	r = read (fd, buffer, sizeof(buffer));
	if (r <= 0) return r;
	buffer_i = 0;
	while (buffer_i < r)
	{
		/* Parse events and queue them. */
		pevent = (struct inotify_event *) &buffer[buffer_i];
		event_size = offsetof (struct inotify_event, name) + pevent->len;
		q_event_size = offsetof (struct queue_entry, inot_ev.name) + pevent->len;
		event = malloc (q_event_size);
		memmove (&(event->inot_ev), pevent, event_size);
		queue_enqueue (event, q);
		buffer_i += event_size;
		count++;
	}
	return count;
}


/* If many files come in at once we really don't want to process
 * them as they arrive, thus the select is set on a time out and
 * all files arriving within this window are queued in a list. The
 * files are processed once the select triggers on a timeout, that
 * is no changes have arrived within the specified timeoutval. We can
 * do this in this simple way as not a lot of files arrive or are
 * modified in this directory.
 */
int process_inotify_events (queue_t q, int fd)
{
	int res;
	struct timeval timeout, *timeoutptr;
	fd_set rfds;

	while(keep_running)
	{
		FD_ZERO(&rfds);
		FD_SET(fd, &rfds);
		timeoutptr = NULL;
		if(timeoutval > 0)
		{
			timeout.tv_sec = timeoutval;
			timeout.tv_usec = 0;
			timeoutptr = &timeout;
		}
		res = select(FD_SETSIZE, &rfds, NULL, NULL, timeoutptr);
		if(res > 0)
		{
			if(read_events(q, fd) > 0)
				handle_events (q);
		}
		else if(res == 0)	/* timeout */
		{
			int ndx = 0;
			/*
			 * Free the list of files the daemon has written itself as
			 * the list may be added to during the processing.
			 */
			FREELIST(wfiles, nwfiles);
			nwfiles = 0;
			/*
			 * timeoutval is set 0 before the processing as it is possible
			 * for events to add files to the lists while calculation is in
			 * progress if an external program is being used. In this case
			 * timeoutval will be set non-zero.
			 */
			timeoutval = 0;
			/*
			 * The loop is done this way as there is the possibility of nfiles
			 * growing during calculation if an external program is used. For
			 * the same reason process_monitor_events must follow the loop.
			 * The modify_elements_from_previous_file function must only be
			 * called for new files.
			 */
			while(ndx < nfiles)
			{
				if(files_new[ndx])
					modify_elements_from_previous_file(files[ndx]);
				calculate_rankweight(files+ndx, 1, FALSE);
				ndx++;
			}
			process_monitor_events();
			FREELIST(files, nfiles);
			FREEMEM(files_new);
			nfiles = 0;
		}
	}
	return 0;
}


int watch_dir (int fd, const STRING dirname, unsigned long mask)
{
	int wd;
	wd = inotify_add_watch (fd, dirname, mask);
	if (wd < 0)
	{
		printlog("Cannot add watch for \"%s\" with event mask %lX", dirname, mask);
	}
	return wd;
}


int ignore_wd (int fd, int wd)
{
	int r = inotify_rm_watch (fd, wd);
	if (r < 0) printlog("inotify_rm_watch(fd, wd) failure = %d", errno);
	return r;
}
